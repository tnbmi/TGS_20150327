//==============================================================================
// 
// ビル[bill.cpp]
// Auther: KOUTAROUNISIDA
// 
//==============================================================================

//==============================================================================
// インクルード
//==============================================================================
#include "bill.h"
#include "scene3D.h"
#include "game.h"
#include "manager.h"

//==============================================================================
// マクロ定義
//==============================================================================

//==============================================================================
// クラス
//==============================================================================

//==============================================================================
// 構造体定義
//==============================================================================

//==============================================================================
// グローバル変数
//==============================================================================
//==============================================================================
// 静的変数
//==============================================================================

//==============================================================================
// プロトタイプ宣言
//==============================================================================

//==============================================================================
// ビルコンストラクタ
// 引数:
// 戻値:
//==============================================================================
CBill::CBill(int priority, OBJTYPE objType) : CSceneX(priority, objType)
{
	ZeroMemory(m_pDirtWall,sizeof(WALL_MAX));
	m_bDirt = false;
	m_bClean = true;
	m_VtxMin = D3DXVECTOR3(0.0f,0.0f,0.0f);
	m_VtxMax = D3DXVECTOR3(0.0f,0.0f,0.0f);

	m_color = D3DXCOLOR(1.0f,1.0f,1.0f,0.0f);
}

//==============================================================================
// ビルデストラクタ
// 引数:
// 戻値:
//==============================================================================
CBill::~CBill()
{
}

//==============================================================================
// ビルの生成
// 引数:デバイス
// 戻値:無
//==============================================================================
CBill *CBill::Create(LPDIRECT3DDEVICE9 device,D3DXVECTOR3 pos,D3DXVECTOR3 rot,CImport::XFILES xFile)
{
	CBill *pointer = new CBill();
	pointer->Init(device,pos,rot,xFile);

	return pointer;
}

//==============================================================================
// ビル初期化処理
// 引数:
// 戻値:
//==============================================================================
HRESULT CBill::Init(LPDIRECT3DDEVICE9 device,D3DXVECTOR3 pos,D3DXVECTOR3 rot,CImport::XFILES xFile)
{
	m_pos = pos;
	m_rot = rot;

	CSceneX::Init(device,xFile);

	m_VtxMin = CImport::GetVtxSizeMin(xFile);
	m_VtxMax = CImport::GetVtxSizeMax(xFile);

	// 汚れた壁
	for( int nCntWall = 0; nCntWall < WALL_MAX; nCntWall++ )
	{
		m_pDirtWall[nCntWall] = CScene3D::Create(device,CImport::TEX_WALL);
		m_pDirtWall[nCntWall]->SetColor(m_color);
	}

	// サイズ
	m_pDirtWall[0]->SetSize((m_VtxMax.x - m_VtxMin.x),(m_VtxMax.y - m_VtxMin.y)*0.6,0.0f);
	m_pDirtWall[1]->SetSize((m_VtxMax.x - m_VtxMin.x),(m_VtxMax.y - m_VtxMin.y)*0.6,0.0f);
	m_pDirtWall[2]->SetSize((m_VtxMax.x - m_VtxMin.x),(m_VtxMax.y - m_VtxMin.y)*0.6,0.0f);
	m_pDirtWall[3]->SetSize((m_VtxMax.x - m_VtxMin.x),(m_VtxMax.y - m_VtxMin.y)*0.6,0.0f);

	// 回転
	m_pDirtWall[1]->SetRot(D3DXVECTOR3(0.0f,3.14f/2,0.0f));;
	m_pDirtWall[2]->SetRot(D3DXVECTOR3(0.0f,-3.14f/2,0.0f));;
	m_pDirtWall[3]->SetRot(D3DXVECTOR3(0.0f,3.14f,0.0f));

	// 座標
	m_pDirtWall[0]->SetPos(D3DXVECTOR3(m_pos.x,m_pos.y,m_pos.z-((m_VtxMax.z - m_VtxMin.z)*0.5f) ));		// 手前
	m_pDirtWall[1]->SetPos(D3DXVECTOR3(m_pos.x - ((m_VtxMax.x - m_VtxMin.x) * 0.5f ),m_pos.y,m_pos.z));		// 左
	m_pDirtWall[2]->SetPos(D3DXVECTOR3(m_pos.x+((m_VtxMax.x - m_VtxMin.x) * 0.5f ),m_pos.y,m_pos.z));		// 右
	m_pDirtWall[3]->SetPos(D3DXVECTOR3(m_pos.x,m_pos.y,m_pos.z+((m_VtxMax.z - m_VtxMin.z)*0.5f) ));		// 奥

	return S_OK;
}

//==============================================================================
// ビル終了処理
// 引数:無
// 戻値:無
//==============================================================================
void CBill::Uninit(void)
{
	Delete();
}

//==============================================================================
// ビル更新処理
// 引数:無
// 戻値:無
//==============================================================================
void CBill::Update(void)
{
	Defile();
}

//==============================================================================
// ビル描画処理
// 引数:無
// 戻値:無
//==============================================================================
void CBill::Draw(void)
{
	CSceneX::Draw();
}

//==============================================================================
// ビルが汚れているかどうか
// 引数:無
// 戻値:無
//==============================================================================
bool CBill::GetDirtComplete(void)
{
	if( m_color.a >= 1.0f )
	{
		m_color.a = 1.0f;
		m_bClean = false;
		m_bDirt = true;
		return true;
	}

	return false;
}

//==============================================================================
// ビルを汚す
// 引数:無
// 戻値:無
//==============================================================================
bool CBill::Defile(void)
{
	m_color.a += 0.003f;

	for( int nCntWall = 0; nCntWall < WALL_MAX;nCntWall++ )
	{
		m_pDirtWall[nCntWall]->SetColor(m_color);
	}

	return GetDirtComplete();
}

//==============================================================================
// ビルを浄化
// 引数:無
// 戻値:無
//==============================================================================
bool CBill::GetCleanComplete(void)
{
	if( m_color.a <= 0.0f )
	{
		m_color.a = 0.0f;
		m_bClean = true;
		m_bDirt = false;
		return true;
	}

	return false;
}

//==============================================================================
// ビルを浄化
// 引数:無
// 戻値:無
//==============================================================================
bool CBill::Clean(void)
{
	m_color.a -= 0.003f;

	for( int nCntWall = 0; nCntWall < WALL_MAX;nCntWall++ )
	{
		m_pDirtWall[nCntWall]->SetColor(m_color);
	}

	return GetCleanComplete();
}
// EOF